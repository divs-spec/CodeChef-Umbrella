ðŸ”’ Restricted Removals
You are given two binary arrays, A and B, of lengths N and M respectively.

You can perform the following operation any number of times:

Choose an index i (1 â‰¤ i â‰¤ min(|A|, M)) such that
A[i] == B[i]
(Here, |A| denotes the current length of array A.)

Remove the element A[i] from A, reducing its length by 1.

After removal, re-index the elements of A starting from 1 without changing their order.

ðŸ§© Example
Suppose:
A = [0, 0, 0, 1]
B = [1, 0]
You can select i = 2 because A[2] = B[2] = 0.

Remove A[2], so now
A = [0, 0, 1]
Re-indexing keeps the order, now A[1] = 0, A[2] = 0, A[3] = 1.

Again, choose i = 2 (valid since A[2] = B[2] = 0) and remove A[2].

Now
A = [0, 1]
No further operations are possible.

ðŸŽ¯ Objective
Determine the minimum possible final length of A after performing these operations optimally.

ðŸ“¥ Input Format
The first line contains an integer T â€” the number of test cases.

Each test case consists of three lines:

The first line contains two integers N and M â€” the initial lengths of arrays A and B.

The second line contains N space-separated integers â€” the elements of array A.

The third line contains M space-separated integers â€” the elements of array B.

ðŸ“¤ Output Format
For each test case, output a single integer on a new line â€” the minimum achievable length of A after applying the operations optimally.

âœ… Constraints
1 â‰¤ T â‰¤ 10^5

1 â‰¤ M â‰¤ N â‰¤ 3 Ã— 10^5

0 â‰¤ A[i], B[i] â‰¤ 1

The sum of all N over all test cases does not exceed 3 Ã— 10^5
